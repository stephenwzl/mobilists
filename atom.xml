<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eleme Mobilists</title>
  
  <link href="/mobilists/atom.xml" rel="self"/>
  
  <link href="http://eleme.io/mobilists/"/>
  <updated>2016-04-12T08:30:09.000Z</updated>
  <id>http://eleme.io/mobilists/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ReactiveCocoa实践（一）</title>
    <link href="http://eleme.io/mobilists/2016/04/12/ReactiveCocoa%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://eleme.io/mobilists/2016/04/12/ReactiveCocoa实践（一）/</id>
    <published>2016-04-12T03:57:32.000Z</published>
    <updated>2016-04-12T08:30:09.000Z</updated>
    
    <content type="html">&lt;p&gt;ReactiveCocoa(以下简称RAC)是iOS上函数响应式编程（Functional Reactive Programming，FRP）的框架，这个和我们平时面向对象（OOP）的编程方式有挺大的区别。本文通过在项目中使用RAC来实现一个小功能，让大家了解一下RAC。&lt;/p&gt;
&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;有一个需求，在搜索页搜索时，需要先判断输入内容是否合法（2个字符以上），同时需要500毫秒的延迟，减少用户输入过程中频繁发起请求。这个功能非常适合用RAC来实现。FRP的核心是信号（signal），而输入框文本变化实质是一种信号，我们可以通过对信号的处理来完成这个功能。&lt;/p&gt;
&lt;h1 id=&quot;Signal&quot;&gt;&lt;a href=&quot;#Signal&quot; class=&quot;headerlink&quot; title=&quot;Signal&quot;&gt;&lt;/a&gt;Signal&lt;/h1&gt;&lt;p&gt;RAC中最核心的类RACSignal，是一系列可以被监测的数据流。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信号类(RACSignal)，只是表示当数据改变时，信号内部会发出数据.&lt;/li&gt;
&lt;li&gt;默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。&lt;/li&gt;
&lt;li&gt;如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个简单例子:&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;figcaption&gt;&lt;span&gt;RACSignal&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;RACSignal *signal = [RACSignal createSignal:^RACDisposable *(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;RACSubscriber&amp;gt; subscriber) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// block调用时刻：每当有订阅者订阅信号，就会调用block。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 发送信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [subscriber sendNext:@&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 发送完成信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [subscriber sendCompleted];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 订阅信号,才会激活信号.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[signal subscribeNext:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// block调用时刻：每当有信号发出数据，就会调用block.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;接收到数据:%@&quot;&lt;/span&gt;,x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同时也支持使用宏来快速地生成信号&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;figcaption&gt;&lt;span&gt;KVO&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[RACObserve(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, searchText) subscribeNext:^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *text) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, text);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;RACObserve&lt;/code&gt;通过&lt;code&gt;- (RACSignal *)rac_valuesForKeyPath: observer:&lt;/code&gt;来生成了一个信号，&lt;br&gt;其使用了KVO来监听property的变化，只要searchText被自己或外部改变，block就会被执行。只要是支持KVO的property都可以被RACObserve来生成一个信号。&lt;/p&gt;
&lt;h2 id=&quot;Operators&quot;&gt;&lt;a href=&quot;#Operators&quot; class=&quot;headerlink&quot; title=&quot;Operators&quot;&gt;&lt;/a&gt;Operators&lt;/h2&gt;&lt;p&gt;信号的处理是非常方便的，可以被修改(map)，也可以被过滤（filter），还可以被节流(throttle,一段时间内不在发送新的信号)等等。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;figcaption&gt;&lt;span&gt;Operators&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[[RACObserve(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, searchText)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   filter:^&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *text) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; text.length &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  throttle:&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; subscribeNext:^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *searchText) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; search:searchText];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上的代码通过对原始信号的处理（filter,throttle），生成了一下新的信号，过滤了输入字符长度小于等于2，同时在一定500毫秒内，不接收任何信号内容，过了500毫秒才获取最后发送的信号内容发出。&lt;/p&gt;
&lt;h1 id=&quot;Implementation&quot;&gt;&lt;a href=&quot;#Implementation&quot; class=&quot;headerlink&quot; title=&quot;Implementation&quot;&gt;&lt;/a&gt;Implementation&lt;/h1&gt;&lt;p&gt;当然由于block的循环引用，我们必须像往常一样使用weakSelf，strongSelf。RAC在RACEXTScope.h中定义了 &lt;code&gt;@weakify()&lt;/code&gt; 和 &lt;code&gt;@strongify()&lt;/code&gt; 来方便我们使用。&lt;code&gt;@weakify()&lt;/code&gt;实际上定义了一个_weak的&lt;code&gt;self_weak_&lt;/code&gt; 变量，而&lt;code&gt;@strongify()&lt;/code&gt;则在block定义了一个指向&lt;code&gt;self_weak_&lt;/code&gt;的_strong的self指针。最终代码：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;figcaption&gt;&lt;span&gt;Final Code&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@weakify(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[[RACObserve(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, searchText)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   filter:^&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *text) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; text.length &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  throttle:&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; subscribeNext:^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *searchText) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   @strongify(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; search:searchText];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;Written by 饿了么iOS组 － &lt;a href=&quot;https://github.com/zhungxd&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;zhungxd&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;ReactiveCocoa(以下简称RAC)是iOS上函数响应式编程（Functional Reactive Programming，FRP）的框架，这个和我们平时面向对象（OOP）的编程方式有挺大的区别。本文通过在项目中使用RAC来实现一个小功能，让大家了解一下RAC。&lt;
    
    </summary>
    
      <category term="iOS" scheme="http://eleme.io/mobilists/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://eleme.io/mobilists/tags/iOS/"/>
    
      <category term="ReactiveCocoa" scheme="http://eleme.io/mobilists/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>饿了么Android插件化开发实践（一）</title>
    <link href="http://eleme.io/mobilists/2016/03/28/%E9%A5%BF%E4%BA%86%E4%B9%88%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://eleme.io/mobilists/2016/03/28/饿了么插件化开发实践（一）/</id>
    <published>2016-03-28T09:18:09.000Z</published>
    <updated>2016-04-12T08:30:09.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;u75DB_u70B9&quot;&gt;&lt;a href=&quot;#u75DB_u70B9&quot; class=&quot;headerlink&quot; title=&quot;痛点&quot;&gt;&lt;/a&gt;痛点&lt;/h2&gt;&lt;p&gt;随着饿了么APP业务急速的发展，项目组内部各个模块的业务越来越多，同时其他项目组也有在主APP集成的需求，现行的Single Code Repo越来越不适合项目的推进。&lt;/p&gt;
&lt;h4 id=&quot;u56E2_u961F_u5185_u90E8_u9700_u6C42&quot;&gt;&lt;a href=&quot;#u56E2_u961F_u5185_u90E8_u9700_u6C42&quot; class=&quot;headerlink&quot; title=&quot;团队内部需求&quot;&gt;&lt;/a&gt;团队内部需求&lt;/h4&gt;&lt;p&gt;目前饿了么APP是基于业务分成Shopping、Booking、Order、Account、Marketing和Application六个模块，每个模块由相关的开发人员进行负责。APP方法数早就超过了65k，最新发布的5.9.0版本方法数已经到达了85k。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、业务量比较复杂，六个模块一共占去了30k

2、为了避免开发中出现大量的boilerplate code，写了很多工具，在compile time 
   auto generate code

3、业务之外，项目中也依赖了很多团队各位小伙伴写的给力库，比如图片解析、HotFix、ORM

4、同时团队对开源也比较活跃，使用了一些很赞的library，如retrofit、RxJava、OkHttp

5、再加上庞大的Android Support Library
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法数越来越大，codebase也越来越庞大。快速的发版周期，codebase只会越来越庞大，这时来自团队内部推动模块化开发的声音逐渐起来。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、不管是开发new feature，还是对代码的重构，引入bug的风险也越来越大

2、虽然基于业务分包，代码逻辑还算比较清晰，但是各个模块的耦合也越来越重

3、在同一repo下开发，一个模块的重构很可能会影响到其他模块，导致小伙伴对refactor code
   比较谨慎，不利于个人能力的发挥，也不利于项目的发展，这当然不是我们愿意看到的
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;u516C_u53F8_u5185_u90E8_u9700_u6C42&quot;&gt;&lt;a href=&quot;#u516C_u53F8_u5185_u90E8_u9700_u6C42&quot; class=&quot;headerlink&quot; title=&quot;公司内部需求&quot;&gt;&lt;/a&gt;公司内部需求&lt;/h4&gt;&lt;p&gt;使用过饿了么APP的同学都知道，饿了么首页有很多运营位，这些运营位有一些是被其他事业部占去的，比如早餐。这些坑位的产品同学也希望他们的页面如丝滑般流畅，对用户体验比较有要求，他们不满足于H5，也不满足于react-native。这种情况下，只能上native code了，但是不同项目组之间有着不同的研发周期，使得我们一起维护一个codebase的想法不大现实。&lt;/p&gt;
&lt;h2 id=&quot;Plugin_Dev__u89C4_u5212&quot;&gt;&lt;a href=&quot;#Plugin_Dev__u89C4_u5212&quot; class=&quot;headerlink&quot; title=&quot;Plugin Dev 规划&quot;&gt;&lt;/a&gt;Plugin Dev 规划&lt;/h2&gt;&lt;p&gt;针对插件化开发的规划，定义了几点需求。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、基于模块进行拆分，把一个不易维护的大APP变成多个精简的小APP

2、满足公司内部的需求，为其他团队提供插件支持，最好可以直接把一个独立的APK load起来

3、可随意加载、卸载插件APP

4、插件APP可免升级更新

5、满足不同的研发周期，可降级展示插件APP，如 H5/native随意切换显示

6、隔离插件的crash

7、安全性校验，防止插件被劫持
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;u5C0F_u7ED3&quot;&gt;&lt;a href=&quot;#u5C0F_u7ED3&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h2&gt;&lt;p&gt;面对上面的业务场景，我们就理所当然的走上了插件化的不归路了。所幸2015年国内Android圈迎来了一波开源小高潮，有一些比较成熟的案例和library可供参考，我们饿了么在这条路上不是一个人在奋斗。业务达到一定量级瓶颈，codebase越来越难以维护的场景下，插件化开发是目前比较靠谱的一条路，很多的同学都已经在这路上走了很远，比如携程、360。&lt;/p&gt;
&lt;p&gt;来自wequick的&lt;a href=&quot;https://github.com/wequick/Small&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Small&lt;/a&gt;、还有CtripMobile的&lt;a href=&quot;https://github.com/CtripMobile/DynamicAPK&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DynamicAPK&lt;/a&gt;都是通过在同一进程中加载，重心放在在资源的冲突解决上；而来自Qihoo360的&lt;a href=&quot;https://github.com/Qihoo360/DroidPlugin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DroidPlugin&lt;/a&gt;的实现则独树一帜，为了避免处理复杂的资源问题，直接一个Plugin对应一个独立的process，构建了一个沙箱，一个运行环境。&lt;/p&gt;
&lt;p&gt;基于不同的实现方式，大致可以把插件化开发的方向分成两个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、Host &amp;amp; Plugin in a single process

2、create another process when load a plugin
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是一个开篇文章，后面会针对这两种不同的实现方式分别做详细的分析和解读。有兴趣的同学可以在评论区留言&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u75DB_u70B9&quot;&gt;&lt;a href=&quot;#u75DB_u70B9&quot; class=&quot;headerlink&quot; title=&quot;痛点&quot;&gt;&lt;/a&gt;痛点&lt;/h2&gt;&lt;p&gt;随着饿了么APP业务急速的发展，项目组内部各个模块的业务越来越多，同时其他项目组也有在主APP集成的需求
    
    </summary>
    
      <category term="Android" scheme="http://eleme.io/mobilists/categories/Android/"/>
    
    
      <category term="Android" scheme="http://eleme.io/mobilists/tags/Android/"/>
    
      <category term="Plugin" scheme="http://eleme.io/mobilists/tags/Plugin/"/>
    
      <category term="插件化" scheme="http://eleme.io/mobilists/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>用UIKit Dynamics模仿UIScrollView</title>
    <link href="http://eleme.io/mobilists/2016/03/15/%E7%94%A8UIKit-Dynamics%E6%A8%A1%E4%BB%BFUIScrollView/"/>
    <id>http://eleme.io/mobilists/2016/03/15/用UIKit-Dynamics模仿UIScrollView/</id>
    <published>2016-03-15T10:46:06.000Z</published>
    <updated>2016-03-16T07:11:17.000Z</updated>
    
    <content type="html">&lt;p&gt;饿了么在上个版本的时候对餐厅页做了很大的改动, 无论是视觉上还是交互上都有很不错的效果. 为了实现这种效果, 我们自己用UIPanGestureRecognizer和UIKit Dynamics模拟了系统的UIScrollView, 包括惯性滚动, 弹性, 橡皮筋(RubberBanding)效果.&lt;br&gt;&lt;img src=&quot;/mobilists/2016/03/15/用UIKit-Dynamics模仿UIScrollView/UXRecord.gif&quot; alt=&quot;效果&quot; title=&quot;效果&quot;&gt;&lt;/p&gt;
&lt;p&gt;在刚接到这个任务的时候, 有过几种想法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这个效果很像是UITableView加上Header的Parallel效果&lt;/li&gt;
&lt;li&gt;可以在一个UIScrollView上面嵌套一个UITableView作为子视图&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些方案都被否决了. 第一种方案, 因为当前页面不仅有两个TableView(食物类别和菜单), 而且要支持左右滚动在”商品”, “评价”, “详情”三个页面切换. 用TableView的header做视差效果是不太可能做到的. 对第二种方案, 是在&lt;code&gt;-[UIScrollViewDelegate scrollViewDidScroll:]&lt;/code&gt;中再手动修改其中一个ScrollView的&lt;code&gt;contentOffset&lt;/code&gt;, 使得当前的两个scrollView的&lt;code&gt;contentOffset&lt;/code&gt;都是正确的, 但是难点是很难去指定手指在屏幕上滑动的时候, 是父view还是子view的UIPanGestureRecognizer手势被响应. 而考虑先禁用其中的一个手势(比如子view的), 先让父View的手势可以驱动父View的&lt;code&gt;contentOffset&lt;/code&gt;改变, 直到父view的&lt;code&gt;contentOffset&lt;/code&gt;到了某个位置再启用子view的手势, 禁用父view的. 这带来一个问题, 在切换手势的enable的时候, 即使手指没有离开屏幕, 但是手势已经禁用, 导致滚动中断, 除非手指离开屏幕后重新触摸才能再次滚动, 这样的效果比较不流畅, 并且其中的逻辑比较复杂, 不太容易处理. 或者子类UIScrollView和UITableView, 在手势代理&lt;code&gt;gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer&lt;/code&gt; 返回YES, 使得两个ScrollView可以同时滚动, 然后在&lt;code&gt;scrollViewDidScroll:&lt;/code&gt;中还原其中一个ScrollView的contentOffset. 但是这样导致逻辑变得复杂, 因为视图中的手势太多. 把ScrollView添加为另一个ScrollView的子视图并不推荐.&lt;/p&gt;
&lt;p&gt;最后, 考虑到这个效果订制程度很高, 于是自己去模仿一下UIScrollView的特性.&lt;/p&gt;
&lt;p&gt;首先说明一下视图的结构:&lt;br&gt;&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&amp;lt;ParentViewController.View&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   |&lt;span class=&quot;string&quot;&gt; &amp;lt;Container&amp;gt; //UIView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt; &amp;lt;SegmentView&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt; &amp;lt;ScrollView&amp;gt; //仅左右滑动(pagingEnabled)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt; &amp;lt;ChildViewController1.View&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt; &amp;lt;CategoryListView&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt; &amp;lt;FoodListView&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt; &amp;lt;ChildViewController2.View&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt; &amp;lt;RatingListView&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt; &amp;lt;ChildViewController3.View&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt;    &lt;/span&gt;|&lt;span class=&quot;string&quot;&gt; &amp;lt;SummaryListView&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;ParentViewController就是从首页Push进入的ViewController, 在它的View上放置了一个Container(一个普通的UIView), Container的上方是SegmentView,下方是一个左右滑动的ScrollView; 在ScrollView上, 从左往右放置了三个ViewController的View; 所有的tableView视图的bounce都禁用. 由于使用了AutoLayout,&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;figcaption&gt;&lt;span&gt;ViewController&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[Container mas_makeConstraints:^(MASConstraintMaker *make) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   make.left.right.bottom.equalTo(ParentViewController.View);     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   make.top.equalTo(ParentViewController.View).offset(topOffset);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;Container的left, right, bottom都对应ParentViewController.View的left,right,bottom, 我们只需要修改topOffset对应的约束, 就可以做出如下的效果:&lt;/p&gt;
&lt;img src=&quot;/mobilists/2016/03/15/用UIKit-Dynamics模仿UIScrollView/UXRecord_TopConstraint.gif&quot; alt=&quot;效果&quot; title=&quot;效果&quot;&gt;
&lt;p&gt;为了让交互的所有细节都可控, 我们要把FoodListView, RatingListView, SummaryListView的scrollEnabled设置为NO, 也就是将UIScrollView自带的panGestureRecognizer禁用, 然后在Container上加上自己的PanGestureRecognizer. 这样之后只要是和上下滚动相关的交互(tableView的滚动和Container的top的约束)都由自己实现的PanGestureRecognizer完成. 这么做有两点优势, 一是当在上下滑动的时候PanGestureRecognizer一定会触发, 并且在滑动的时候, 可以精确的控制当前手势的位移是修改Container的顶部约束还是修改当前页面的tableView的contentOffset; 二是在手势结束的时候, 可以获取最后手势的速度&lt;code&gt;-[UIPanGestureRecognizer velocityInView:]&lt;/code&gt; 这方便了之后模拟惯性效果.&lt;/p&gt;
&lt;p&gt;在模拟ScrollView的三个特性里面, 最简单的是RubberBanding(橡皮筋效果), 惯性滚动和弹性原理是类似的.&lt;/p&gt;
&lt;h1 id=&quot;RubberBanding&quot;&gt;&lt;a href=&quot;#RubberBanding&quot; class=&quot;headerlink&quot; title=&quot;RubberBanding&quot;&gt;&lt;/a&gt;RubberBanding&lt;/h1&gt;&lt;p&gt;因为只启用了自定义的pan手势, 在普通情况下, 要修改tableView的contentOffset 或者修改Container的顶部约束, 只需要在&lt;code&gt;pan.state == UIGestureRecognizerStateChanged&lt;/code&gt;, 根据&lt;code&gt;[pan translationInView: Container].y&lt;/code&gt;获取垂直方向的手势位移, 修改contentOffset或者约束的变化等于手势位移. 至于RubberBanding, 在垂直方向上有两种可能: Container距离顶部超过某个预设的值, 手势继续向下拖动; 或者tableView的拉到底部之后手势继续向上. 这个时候修改&lt;code&gt;contentOffset&lt;/code&gt;或者顶部约束的变化小于手势位移(比如乘以一个小于1的因数), 就可以模仿出RubberBanding效果.&lt;/p&gt;
&lt;h1 id=&quot;u60EF_u6027__26amp_3B__u5F39_u6027&quot;&gt;&lt;a href=&quot;#u60EF_u6027__26amp_3B__u5F39_u6027&quot; class=&quot;headerlink&quot; title=&quot;惯性 &amp;amp; 弹性&quot;&gt;&lt;/a&gt;惯性 &amp;amp; 弹性&lt;/h1&gt;&lt;p&gt;这里说的惯性效果不仅包括模仿tableView自身的惯性减速修改&lt;code&gt;contentOffset&lt;/code&gt;.&lt;br&gt;还包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在手势结束之后, Container根据惯性的效果动态改变它的顶部约束.&lt;/li&gt;
&lt;li&gt;Container按照惯性效果到顶部后(top约束减小, Container向上移动), 惯性效果没有消失, 继续驱动tableView的&lt;code&gt;contentOffset&lt;/code&gt;修改. (速度传递)&lt;/li&gt;
&lt;li&gt;tableView按照惯性减小&lt;code&gt;contentOffset.y&lt;/code&gt;到0后, 惯性效果继续驱动Container修改顶部约束. (速度传递)&lt;br&gt;同样, 弹性效果也不只是tableView到达超过底部之后放手回弹, 也包括Container距离顶部超过一定距离之后放手回弹效果, 以及可能因为速度传递后导致的回弹.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先简单的考虑只在手势结束后发生的惯性和弹性, 很幸运的是可以获取手势最后一刻的速度&lt;code&gt;[pan velocityInView:Container].y&lt;/code&gt;. 第一反应是使用UIView的springAnimation, 因为它接受传入速度. 但是其他参数比如duration, 其实没有太好的方案去指定, 如果加上速度传递的效果, 它就更无能为力了. 反复滑动系统的ScrollView, 在调用栈发现它是由CADisplayLink驱动的, 发现它的行为和UIKit Dynamics的动画很符合, 而且UIKit Dynamics背后也是CADisplayLink,加上UIDynamicBehavior有个action属性:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;When running, the dynamic animator calls the action block on every animation step.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在每一帧动画的时候都会调用下. 这些组合起来, 足够去模拟ScrollView的各种行为了.&lt;/p&gt;
&lt;p&gt;一般我们使用UIKit Dynamics的时候, 我们是把各种Behaviour直接添加到UIView上, 然后视图就会在它到作用下动起来. 但在现在的情况下, 并不能够直接对视图添加Behaviour. 由于Behaviour实际是对遵循UIDynamicItem协议的对象做物理动画, 所以可以把contentOffset或者顶部约束的值做一层抽象. &lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;figcaption&gt;&lt;span&gt;DynamicItem&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DynamicItem&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;UIDynamicItem&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readwrite&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;CGPoint&lt;/span&gt; center;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;CGRect&lt;/span&gt; bounds;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readwrite&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;CGAffineTransform&lt;/span&gt; transform;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DynamicItem&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (instancetype)init &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; init]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	_bounds = &lt;span class=&quot;built_in&quot;&gt;CGRectMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;DynamicItem的实例可以看作是一个质点, 在垂直方向上, 它的位置(center)可以用来代表Container的位置(top), 也可以用来代表tableView的&lt;code&gt;contentOffset.y&lt;/code&gt;, 它的&lt;code&gt;transform&lt;/code&gt;属性可以不用考虑. &lt;/p&gt;
&lt;p&gt;无论是修改Container的位置还是tableView的&lt;code&gt;contentOffset&lt;/code&gt;, 在惯性或弹性效果的情况下, 只要在action中将约束的值或者&lt;code&gt;contentOffset.y&lt;/code&gt;设置为DynamicItem的&lt;code&gt;center.y&lt;/code&gt;就可以. UIKit Dynamics自己会在每一帧去修改.&lt;/p&gt;
&lt;p&gt;比如惯性效果下修改Container的顶部约束大概是这样的:&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;figcaption&gt;&lt;span&gt;ViewController&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// when pan.state == UIGestureRecognizerStateEnded&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NVMDynamicItem *item = [NVMDynamicItem new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// topOffset表示当前Container距离顶部的距离&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;item.center = &lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, topOffset);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// velocity是在手势结束的时候获取的竖直方向的手势速度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIDynamicItemBehavior&lt;/span&gt; *inertialBehavior = [[&lt;span class=&quot;built_in&quot;&gt;UIDynamicItemBehavior&lt;/span&gt; alloc] initWithItems:@[ item ]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [inertialBehavior addLinearVelocity:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, velocity) forItem:item];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 通过尝试取2.0比较像系统的效果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  inertialBehavior.resistance = &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  inertialBehavior.action = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; itemTop = item.center.y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [Container mas_updateConstraints:^(MASConstraintMaker *make) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      make.top.equalTo(ParentViewController.View).offset(itemTop);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.animator addBehavior:inertialBehavior];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;类似的弹性效果只需使用UIAttachmentBehavior并且设置合适的值, 尝试下来length = 0, damping = 1, frequency = 1.6, 就有不错的回弹效果.&lt;br&gt;修改contentOffset也是类似, 只不过是将在action中修改约束的部分改为修改contentOffset.&lt;/p&gt;
&lt;p&gt;对于速度传递, 完全一样的原理, 唯一的变化就是从获取手势的速度变为获取&lt;code&gt;-[UIDynamicItemBehavior linearVelocityForItem]&lt;/code&gt;的线速度, 然后UIDynamicAnimator移除不需要的动画, 按照上面的例子传入速度再次做惯性动画. &lt;/p&gt;
&lt;p&gt;甚至还可以把UIAttachmentBehavior和UIDynamicItemBehavior同时使用, 模仿有初速度的回弹效果.&lt;/p&gt;
&lt;p&gt;大致的思路就是这样, 只需要注意什么时候调用&lt;code&gt;-[UIDynamicAnimator removeBehavior]&lt;/code&gt;停止动画(比如手势刚开始的时候), 以及action中注意retain cycle.&lt;/p&gt;
&lt;p&gt;有个2014年的&lt;a href=&quot;http://holko.pl/2014/07/06/inertia-bouncing-rubber-banding-uikit-dynamics/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客&lt;/a&gt;已经有了类似的例子, 只是交互简单一些, 原理是一样的.&lt;/p&gt;
&lt;p&gt;而在运用自己的手势去实现ScrollView之后, 碰到了一些细节问题.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自己加到Container上的手势, 很容易误触发tableView的&lt;code&gt;-tableView:didSelectRowAtIndexPath:indexPath&lt;/code&gt;协议方法, 导致很容易Push到下一个页面, 很影响使用. 解决的原理比较简单, 在合适的时机将当前的tableView.userInteractionEnabled设置为NO, 之后在需要的时候恢复. 正好UIDynamicAnimatorDelegate提供了动画将要开始&lt;code&gt;dynamicAnimatorWillResume:&lt;/code&gt;和暂停(包括移除bahaviour)&lt;code&gt;dynamicAnimatorDidPause:&lt;/code&gt;的回调. 就在这两个地方分别设置, 效果还可以接受.&lt;/li&gt;
&lt;li&gt;当tableView在UIKit Dynamics的作用下滚动时, 或者是快速上下滑动的时候, 很容易触发左右滑动的ScrollView切换页面. 解决方案比较tricky: 自定义了UIScrollView的子类, 在子类中将gestureRecognizerShouldBegin:重写, 对于panGestureRecognizer的情况, 在它的水平速度和垂直速度的夹角在一定范围内强制返回NO. 这样就大大减小了误触发左右滚动的操作. 但是还是希望有更好的解决方案.&lt;/li&gt;
&lt;li&gt;还有一个很常见的问题, 点击状态栏, 正常情况下系统能够将ScrollView滚动到顶部, 而在一个Window中有多个ScrollView的时候, 它是不一定成功的. 正确的解决方案应该是将当前页面需要响应系统statusBar点击的ScrollView的&lt;code&gt;scrollsToTop&lt;/code&gt;设置为YES, 其他都设置为NO, 并且&lt;code&gt;scrollsToTop&lt;/code&gt;为YES的只能有一个, 这种情况下理论上是可以work的. 但是在解决第一个问题的时候, 导致了这种解决方法有时候不成功. 因为发现在一个UIScrollView的&lt;code&gt;userInteractionEnabled == NO&lt;/code&gt;的时候, 状态栏点击返回顶部效果是无效的(比如正在惯性滚动的时候, 状态还是NO, 这个时候点击statusBar); 加上在最左边的页面有两个tableView需要同时滚动到顶部. 只能换个解决方案. 子类化了全局的UIWindow, 重写它的&lt;code&gt;-pointInside:withEvent:&lt;/code&gt;, 在statusBar区域被点击的时候发出通知, 监听到后手动设置contentOffset到0. &lt;/li&gt;
&lt;li&gt;由于之前很多控件是AutoLayout写的, 比如cell, 因为现在实现的方案会频繁修改约束, 导致滑动很卡(之前在iPhone 6就感受到卡顿了). 之后用手动布局改了一部分cell, 确实流畅了很多.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然UIKit Dynamics平时很少用到, 不过在关键时刻也发挥了巨大的作用, 很好奇Apple在实现UIScrollView会不会也用到了它.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Written by 饿了么iOS组 － &lt;a href=&quot;https://github.com/philcai1993&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PhilCai&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;饿了么在上个版本的时候对餐厅页做了很大的改动, 无论是视觉上还是交互上都有很不错的效果. 为了实现这种效果, 我们自己用UIPanGestureRecognizer和UIKit Dynamics模拟了系统的UIScrollView, 包括惯性滚动, 弹性, 橡皮筋(Rubb
    
    </summary>
    
      <category term="iOS" scheme="http://eleme.io/mobilists/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://eleme.io/mobilists/tags/iOS/"/>
    
      <category term="UIScrollView" scheme="http://eleme.io/mobilists/tags/UIScrollView/"/>
    
      <category term="UIKit Dynamics" scheme="http://eleme.io/mobilists/tags/UIKit-Dynamics/"/>
    
  </entry>
  
  <entry>
    <title>android APP 瘦身</title>
    <link href="http://eleme.io/mobilists/2016/02/25/android-APP-%E7%98%A6%E8%BA%AB/"/>
    <id>http://eleme.io/mobilists/2016/02/25/android-APP-瘦身/</id>
    <published>2016-02-25T09:18:09.000Z</published>
    <updated>2016-03-14T03:24:40.000Z</updated>
    
    <content type="html">&lt;p&gt;随着饿了么业务的快速发展，直接面向用户的APP的功能也越来越多，APP的体积也随之增长。虽然我们研发一直在有意识的从代码和资源角度打磨产品，但是仍是不能比较可观的抑制体积的增长，经历整个2015年多个版本的迭代，增长了一倍不止。所以到了这个时候，为了更小的减少用户升级更新的成本，APP瘦身之旅势在必行。下面将根据不同的瘦身角度来实战分析。 &lt;/p&gt;
&lt;h2 id=&quot;1_u3001PNG&quot;&gt;&lt;a href=&quot;#1_u3001PNG&quot; class=&quot;headerlink&quot; title=&quot;1、PNG&quot;&gt;&lt;/a&gt;1、PNG&lt;/h2&gt;&lt;p&gt;  1.切图只要xxhdpi&lt;br&gt;      基于数据分析，绝大多数用户的设备分辨率都是2x、3x，&lt;br&gt;      在切图方面只选取xxhdpi一套图，通过在不同分辨率的机器上测试，UI效果以及内存开销都可以接受&lt;/p&gt;
&lt;p&gt;2.切图技巧&lt;br&gt;      大尺寸的切图，可考虑分切成多个小图片&lt;br&gt;      不需要alpha通道的图片，可以考虑使用jpg&lt;br&gt;      如果minsdk为4.2.1+，可以考虑把png全部换成webp；低版本可以通过第三方webp解码lib使用&lt;/p&gt;
&lt;p&gt;  3.切图压缩&lt;br&gt;      切图统一压缩，以防万一，在release打包的时候，再一次性压缩。&lt;br&gt;      压缩的工具可以选取&lt;a href=&quot;https://tinypng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TinyPng&lt;/a&gt; 、&lt;a href=&quot;http://www.imagemagick.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ImageMagick&lt;/a&gt;（可以封装成GUI/command tool/gradle task）&lt;/p&gt;
&lt;p&gt;   4.SVG/Vector Drawable&lt;br&gt;      自Lollipop开始，Android已经支持&lt;a href=&quot;http://developer.android.com/intl/zh-cn/reference/android/graphics/drawable/VectorDrawable.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;VectorDrawable&lt;/a&gt;和&lt;a href=&quot;http://developer.android.com/intl/zh-cn/reference/android/graphics/drawable/AnimatedVectorDrawable.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AnimatedVectorDrawable&lt;/a&gt;，这个通过xml文本file完成原来切图png的功能，切图的工作基本就被托管了&lt;br&gt;      Lollipop以下，更新你的support library到&lt;a href=&quot;http://android-developers.blogspot.com/2016/02/android-support-library-232.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;23.2&lt;/a&gt;，VectorDrawableCompat已经可以兼容到api7了，AnimatedVectorDrawableCompat兼容到api11&lt;/p&gt;
&lt;p&gt;   5.删除无用资源&lt;br&gt;      通过&lt;strong&gt;lint&lt;/strong&gt;发现无用资源删除&lt;br&gt;      android gradle plugin 开启&lt;a href=&quot;http://tools.android.com/tech-docs/new-build-system/resource-shrinking&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;shrinkResources&lt;/a&gt;&lt;br&gt;      …&lt;/p&gt;
&lt;h2 id=&quot;2_u3001_u8D44_u6E90res&quot;&gt;&lt;a href=&quot;#2_u3001_u8D44_u6E90res&quot; class=&quot;headerlink&quot; title=&quot;2、资源res&quot;&gt;&lt;/a&gt;2、资源res&lt;/h2&gt;&lt;p&gt;有同学会有疑问，res混淆和APP瘦身有什么关系呢？&lt;br&gt;这就需要大家对Android中资源的查找有一定的了解，code通过R文件中的常量值访问资源，但是是如何映射到具体的资源文件上的呢？这里就需要介绍resources.arsc，简单理解这是一个二进制文件，负责存储res资源的映射关系。如果我们精简资源的路径，如把res/drawable-xxhdpi/hello.png转为 a/z/p.png，这样的话resources.arsc中存储的信息量就会变少，对应的体积就会缩小。&lt;br&gt;    目前这种思路有开源的方案，可参考&lt;a href=&quot;https://github.com/shwenzhang/AndResGuard&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AndResGuard&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;3_u3001jniLibs&quot;&gt;&lt;a href=&quot;#3_u3001jniLibs&quot; class=&quot;headerlink&quot; title=&quot;3、jniLibs&quot;&gt;&lt;/a&gt;3、jniLibs&lt;/h2&gt;&lt;p&gt;根据业务面向的用户及设备，可考虑移除mips、x86平台的so&lt;/p&gt;
&lt;p&gt;64位的cpu会兼容32位，可以考虑不保留armeabi-64&lt;/p&gt;
&lt;p&gt;主流的arm架构有armv5、armv7、armv8，而它们是向后兼容的。在计算性能可接受的情况下，只保留armeabi一个；armv7加了FPU，大大提升了浮点运算的效率，必要时也可放入armeabi，在使用的时候手动去基于cpu abi手动load&lt;/p&gt;
&lt;p&gt;应用市场升级安装，我们无法把控具体升级的机器cpu abi。但是如果APP内升级的话，我们可以通过&lt;a href=&quot;http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ABIs Splits&lt;/a&gt;打出多个apk升级包，基于不同的abi分发不同的最新apk&lt;/p&gt;
&lt;p&gt;如果so文件体积比较大的情况下，可不打入apk中，后面通过在线加载后再手动load。一个比较典型的场景就是集成自定义WebView的时候，内核so的体积很大，高达10MB+，这个时候WIFI在线load就是个不错的方案&lt;/p&gt;
&lt;p&gt;优化native code。native code会直接影响so的大小，所以从根源上做努力很有必要，比如Do not use Exceptions and RTTI。具体参考&lt;a href=&quot;https://blog.algolia.com/android-ndk-how-to-reduce-libs-size/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Link&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;4_u3001proguard&quot;&gt;&lt;a href=&quot;#4_u3001proguard&quot; class=&quot;headerlink&quot; title=&quot;4、proguard&quot;&gt;&lt;/a&gt;4、proguard&lt;/h2&gt;&lt;p&gt;不知道大家有没有注意到，打包的code文件中包含很多的信息，其中有个就是 &lt;strong&gt;LineNumber&lt;/strong&gt;&lt;br&gt;这个有什么作用呢，就是记录code对应的行号，执行过程中没啥意义。但是如果遇到crash，抓取stack trace去分析的时候，就可以具体到哪一行出了问题。&lt;br&gt;如果你足够丧心病狂、足够对code有信心的话，你可以移除&lt;strong&gt;LineNumber&lt;/strong&gt;信息。&lt;/p&gt;
&lt;h2 id=&quot;5_u3001library&quot;&gt;&lt;a href=&quot;#5_u3001library&quot; class=&quot;headerlink&quot; title=&quot;5、library&quot;&gt;&lt;/a&gt;5、library&lt;/h2&gt;&lt;p&gt;debug依赖的lib，统一在release时不打进APK，或者依赖的lib提供一套空实现&lt;br&gt;大而全的Llbrary的引入有谨慎，guava这样的库就算了。如果你只用到一小部分功能，可以考虑自己做个抽取，或者替换为一个更精小的lib&lt;br&gt;时刻关注library的依赖关系，别一个小lib直接或间接的依赖着一个超大的&lt;br&gt;在重构过程中，记得check下是否有可以删除的lib      &lt;/p&gt;
&lt;h2 id=&quot;6_u3001online_load&quot;&gt;&lt;a href=&quot;#6_u3001online_load&quot; class=&quot;headerlink&quot; title=&quot;6、online load&quot;&gt;&lt;/a&gt;6、online load&lt;/h2&gt;&lt;p&gt;上面提到过一些，这里详细列举下&lt;br&gt;资源加载：大的图片、db文件、so等&lt;br&gt;code加载：即插件化，在线download jar再load，目前有很多开源项目可参考&lt;/p&gt;
&lt;p&gt;以上所列举的措施很多，在瘦身的过程中，基于自身的业务及需求，考虑选取合适的建议。我们饿了么APP这边的目标就是在满足业务的前提下，力求压缩到极致，同时也实现瘦身自动化。在持续优化的过程中，我们团队内部也逐渐积累了一些工具和lib，我们会在合适的时候给开源出来，有兴趣的同学持续关注。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;希望我们的经验能给有需求的同学一些参考和启发，也欢迎大家积极comment&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;APP瘦身是一条持续优化的路，这关乎产品，更关乎情怀&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;随着饿了么业务的快速发展，直接面向用户的APP的功能也越来越多，APP的体积也随之增长。虽然我们研发一直在有意识的从代码和资源角度打磨产品，但是仍是不能比较可观的抑制体积的增长，经历整个2015年多个版本的迭代，增长了一倍不止。所以到了这个时候，为了更小的减少用户升级更新的
    
    </summary>
    
      <category term="Android" scheme="http://eleme.io/mobilists/categories/Android/"/>
    
    
      <category term="Android" scheme="http://eleme.io/mobilists/tags/Android/"/>
    
      <category term="Shrink" scheme="http://eleme.io/mobilists/tags/Shrink/"/>
    
      <category term="APP 瘦身" scheme="http://eleme.io/mobilists/tags/APP-%E7%98%A6%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>详解 iOS 8 `UIPresentationController` Custom Presentation</title>
    <link href="http://eleme.io/mobilists/2016/02/12/%E8%AF%A6%E8%A7%A3-iOS-8-UIPresentationController-custom-presentation/"/>
    <id>http://eleme.io/mobilists/2016/02/12/详解-iOS-8-UIPresentationController-custom-presentation/</id>
    <published>2016-02-12T05:28:40.000Z</published>
    <updated>2016-02-12T13:28:26.000Z</updated>
    
    <content type="html">&lt;p&gt;现在大多数 app 都已经支持 iOS 7+ 有一段时间了，距离支持 iOS 8+ 的时间也是屈指可数（希望如此…）了。iOS 8 新增的 API 中有一个 &lt;code&gt;UIPresentationController&lt;/code&gt; 一直比较陌生，本文将简略介绍使用 &lt;code&gt;UIPresentationController&lt;/code&gt; 来实现一个自定义 presentation 的过程，然后详细解读 &lt;code&gt;UIKit&lt;/code&gt; 是如何操作这一过程以及我们能够如何地参与其中。&lt;/p&gt;
&lt;h1 id=&quot;Final_Result&quot;&gt;&lt;a href=&quot;#Final_Result&quot; class=&quot;headerlink&quot; title=&quot;Final Result&quot;&gt;&lt;/a&gt;Final Result&lt;/h1&gt;&lt;p&gt;下图是 demo 的效果：黄色背景的 view controller （之后简称vc）present 了一个红色背景的 vc，present 的过程是自定义的，红色背景的 vc 被 present 出来后没有占满整个屏幕，周围有一圈黑色半透明背景可以透视看到黄色 vc。&lt;br&gt;&lt;img src=&quot;/mobilists/2016/02/12/详解-iOS-8-UIPresentationController-custom-presentation/final_result.gif&quot; alt=&quot;最终的结果&quot; title=&quot;最终的结果&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Implementation&quot;&gt;&lt;a href=&quot;#Implementation&quot; class=&quot;headerlink&quot; title=&quot;Implementation&quot;&gt;&lt;/a&gt;Implementation&lt;/h1&gt;&lt;p&gt;Demo 的效果用 iOS 7 的自定义 presentation 动画的 API 就能够实现，只需要使 presented vc 的背景色是黑色半透明，然后在上面加一个比自己 view 小一圈的红色区域就行。这里我们先不讨论为什么能够用 iOS 7 的 API 实现了，还需要用 iOS 8 的 &lt;code&gt;UIPresentationController&lt;/code&gt;，直接先看如何实现。&lt;/p&gt;
&lt;p&gt;我们创建一个 &lt;code&gt;UIPresentationController&lt;/code&gt; 的 subclass，在其中自己管理一个 &lt;code&gt;dimmingView&lt;/code&gt;（黑色半透明），并 override 一些方法，在 present 的过程中把 presented vc 的 view 的 &lt;code&gt;frame&lt;/code&gt; 设置得小一些，并将其加到 &lt;code&gt;dimmingView&lt;/code&gt; 上，然后把 &lt;code&gt;dimmingView&lt;/code&gt; 加入到视图结构中去。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;figcaption&gt;&lt;span&gt;MyPresentationController&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyPresentationController&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;UIPresentationController&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; dimmingView = &lt;span class=&quot;type&quot;&gt;UIView&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt;(presentedViewController: &lt;span class=&quot;type&quot;&gt;UIViewController&lt;/span&gt;, presentingViewController: &lt;span class=&quot;type&quot;&gt;UIViewController&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dimmingView.backgroundColor = &lt;span class=&quot;type&quot;&gt;UIColor&lt;/span&gt;.blackColor().colorWithAlphaComponent(&lt;span class=&quot;number&quot;&gt;0.4&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt;(presentedViewController: presentedViewController, presentingViewController: presentingViewController)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;frameOfPresentedViewInContainerView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;CGRect&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; frame = containerView?.bounds &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;CGRectInset&lt;/span&gt;(frame, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.frameOfPresentedViewInContainerView()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;containerViewWillLayoutSubviews&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; containerView = containerView &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dimmingView.frame = containerView.bounds&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;presentationTransitionWillBegin&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; containerView = containerView,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; presentedView = presentedView(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; coordinator = presentingViewController.transitionCoordinator()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dimmingView.alpha = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    containerView.addSubview(dimmingView)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dimmingView.addSubview(presentedView)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    coordinator.animateAlongsideTransition(&amp;#123; (context) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dimmingView.alpha = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;, completion: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;presentationTransitionDidEnd&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(completed: Bool)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !completed &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      dimmingView.removeFromSuperview()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dismissalTransitionWillBegin&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; coordinator = presentedViewController.transitionCoordinator() &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    coordinator.animateAlongsideTransition(&amp;#123; (context) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.dimmingView.alpha = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;, completion: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dismissalTransitionDidEnd&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(completed: Bool)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; completed &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      dimmingView.removeFromSuperview()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后我们需要一个 animator，涉及的都是 iOS 7 的 API，这里不多做说明。注意 &lt;code&gt;transitionContext.viewForKey(UITransitionContextToViewKey)&lt;/code&gt; 是 iOS 8 新增的 API，这里必须这样来取得 &lt;code&gt;toView&lt;/code&gt; 是因为 presentation controller 可能会提供并不是 presented vc 的 view 来用做 presentation。另外 &lt;code&gt;toView&lt;/code&gt; 的 &lt;code&gt;finalFrame&lt;/code&gt; 同样需要从 context 获取，因为 &lt;code&gt;finalFrame&lt;/code&gt; 可以被 &lt;code&gt;UIPresentationController&lt;/code&gt; 修改为并不是整个屏幕的大小。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;figcaption&gt;&lt;span&gt;TransitioningAnimator&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TransitioningAnimator&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;UIViewControllerAnimatedTransitioning&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;transitionDuration&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(transitionContext: UIViewControllerContextTransitioning?)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;NSTimeInterval&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;animateTransition&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(transitionContext: UIViewControllerContextTransitioning)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;guard&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; toViewController = transitionContext.viewControllerForKey(&lt;span class=&quot;type&quot;&gt;UITransitionContextToViewControllerKey&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; toView = transitionContext.viewForKey(&lt;span class=&quot;type&quot;&gt;UITransitionContextToViewKey&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; containerView = transitionContext.containerView()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; finalFrame = transitionContext.finalFrameForViewController(toViewController)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    toView.frame = finalFrame&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    toView.transform = &lt;span class=&quot;type&quot;&gt;CGAffineTransformMakeScale&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    toView.alpha = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    containerView.addSubview(toView)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;UIView&lt;/span&gt;.animateWithDuration(transitionDuration(transitionContext), delay: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, usingSpringWithDamping: &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;, initialSpringVelocity: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, options: [], animations: &amp;#123; &lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      toView.transform = &lt;span class=&quot;type&quot;&gt;CGAffineTransformIdentity&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      toView.alpha = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;) &amp;#123; completed -&amp;gt; &lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        transitionContext.completeTransition(completed)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;另外还需要一个 &lt;code&gt;TransitioningDelegate&lt;/code&gt;，其作用就是提供之前创建的 presentation controller 以及 animator&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;figcaption&gt;&lt;span&gt;TransitioningDelegate&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TransitioningDelegate&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;UIViewControllerTransitioningDelegate&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;presentationControllerForPresentedViewController&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(presented: UIViewController, presentingViewController presenting: UIViewController, sourceViewController source: UIViewController)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;UIPresentationController&lt;/span&gt;? &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; presentationController = &lt;span class=&quot;type&quot;&gt;MyPresentationController&lt;/span&gt;(presentedViewController: presented, presentingViewController: presenting)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; presentationController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;animationControllerForPresentedController&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;UIViewControllerAnimatedTransitioning&lt;/span&gt;? &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; animator = &lt;span class=&quot;type&quot;&gt;TransitioningAnimator&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; animator;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后，在 present 之前把 &lt;code&gt;TransitioningDelegate&lt;/code&gt; 赋值给 presenting 以及 presented vc。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;figcaption&gt;&lt;span&gt;黄色vc的按钮触发的方法内&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; vc = &lt;span class=&quot;type&quot;&gt;MyViewController&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; myTransitioningDelegate = &lt;span class=&quot;type&quot;&gt;TransitioningDelegate&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transitioningDelegate = myTransitioningDelegate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vc.transitioningDelegate = myTransitioningDelegate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;presentViewController(vc, animated: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;, completion: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过以上的代码就实现了 demo 所示的效果。你肯定会问，我用 iOS 7 的 animator 一样可以做到啊，这是何苦又要多增加一个类（&lt;code&gt;MyPresentationController&lt;/code&gt;）呢？下面我们详细撸一遍 iOS 8 下 present 的过程，撸完之后应该就能够理解了。&lt;/p&gt;
&lt;h1 id=&quot;UIPresentationController&quot;&gt;&lt;a href=&quot;#UIPresentationController&quot; class=&quot;headerlink&quot; title=&quot;UIPresentationController&quot;&gt;&lt;/a&gt;UIPresentationController&lt;/h1&gt;&lt;p&gt;为了便于参考，把 &lt;code&gt;UIPresentationController&lt;/code&gt; 的 API 放在这里，可以直接跳到下一章阅读。&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;figcaption&gt;&lt;span&gt;UIPresentationController&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@available&lt;/span&gt;(iOS &lt;span class=&quot;number&quot;&gt;8.0&lt;/span&gt;, *)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UIPresentationController&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;UIAppearanceContainer&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;UITraitEnvironment&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;UIContentContainer&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;UIFocusEnvironment&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; presentingViewController: &lt;span class=&quot;type&quot;&gt;UIViewController&lt;/span&gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; presentedViewController: &lt;span class=&quot;type&quot;&gt;UIViewController&lt;/span&gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; presentationStyle: &lt;span class=&quot;type&quot;&gt;UIModalPresentationStyle&lt;/span&gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// The view in which a presentation occurs. It is an ancestor of both the presenting and presented view controller&#39;s views.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// This view is being passed to the animation controller.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; containerView: &lt;span class=&quot;type&quot;&gt;UIView&lt;/span&gt;? &amp;#123; &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; delegate: &lt;span class=&quot;type&quot;&gt;UIAdaptivePresentationControllerDelegate&lt;/span&gt;?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt;(presentedViewController: &lt;span class=&quot;type&quot;&gt;UIViewController&lt;/span&gt;, presentingViewController: &lt;span class=&quot;type&quot;&gt;UIViewController&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// By default this implementation defers to the delegate, if one exists, or returns the current presentation style. UIFormSheetPresentationController, and&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// UIPopoverPresentationController override this implementation to return UIModalPresentationStyleFullscreen if the delegate does not provide an&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// implementation for adaptivePresentationStyleForPresentationController:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;adaptivePresentationStyle&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;UIModalPresentationStyle&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@available&lt;/span&gt;(iOS &lt;span class=&quot;number&quot;&gt;8.3&lt;/span&gt;, *)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;adaptivePresentationStyleForTraitCollection&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(traitCollection: UITraitCollection)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;UIModalPresentationStyle&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;containerViewWillLayoutSubviews&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;containerViewDidLayoutSubviews&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// A view that&#39;s going to be animated during the presentation. Must be an ancestor of a presented view controller&#39;s view&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// or a presented view controller&#39;s view itself.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// (Default: presented view controller&#39;s view)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;presentedView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;UIView&lt;/span&gt;?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Position of the presented view in the container view by the end of the presentation transition.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// (Default: container view bounds)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;frameOfPresentedViewInContainerView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;CGRect&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// By default each new presentation is full screen.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// This behavior can be overriden with the following method to force a current context presentation.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// (Default: YES)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;shouldPresentInFullscreen&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Indicate whether the view controller&#39;s view we are transitioning from will be removed from the window in the end of the&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// presentation transition&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// (Default: NO)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;shouldRemovePresentersView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;presentationTransitionWillBegin&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;presentationTransitionDidEnd&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(completed: Bool)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dismissalTransitionWillBegin&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dismissalTransitionDidEnd&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(completed: Bool)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Modifies the trait collection for the presentation controller.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@NSCopying&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; overrideTraitCollection: &lt;span class=&quot;type&quot;&gt;UITraitCollection&lt;/span&gt;?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;The_Presentation_Process&quot;&gt;&lt;a href=&quot;#The_Presentation_Process&quot; class=&quot;headerlink&quot; title=&quot;The Presentation Process&quot;&gt;&lt;/a&gt;The Presentation Process&lt;/h1&gt;&lt;p&gt;我们来详细解读一下 presentation 的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们初始化好将要被 present 的 vc 以及我们的 &lt;code&gt;TransitioningDelegate&lt;/code&gt;，并将之赋值给 presenting 及 presented vc，然后通过我们再熟悉不过的 &lt;code&gt;presentViewController:animated:completion:&lt;/code&gt; 启动 presentation。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIKit&lt;/code&gt; 通过 &lt;code&gt;presentationControllerForPresentedViewController(_:presentingViewController:sourceViewController:)&lt;/code&gt; 来向我们的 &lt;code&gt;TransitioningDelegate&lt;/code&gt; 要一个 &lt;code&gt;UIPresentationController&lt;/code&gt;，在我们的实现中，我们提供了自己写的它的子类 &lt;code&gt;MyPresentationController&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIKit&lt;/code&gt; 向 &lt;code&gt;UIPresentationController&lt;/code&gt; 的 &lt;code&gt;shouldPresentInFullscreen()&lt;/code&gt; 咨询这次 presentation 是否覆盖全屏幕。它的默认值就是 &lt;code&gt;true&lt;/code&gt;。我们也可以返回 &lt;code&gt;false&lt;/code&gt; 从而来一次覆盖部分屏幕的 presentation。&lt;code&gt;UIKit&lt;/code&gt; 在整个 presentation 的过程中会多次咨询这个方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIKit&lt;/code&gt; 咨询 &lt;code&gt;adaptivePresentationStyleForTraitCollection(traitCollection:)&lt;/code&gt; 来获取一个在特定 trait collection 下 make sense 的 presentation style。比如说在横屏的 phone 上以 popover 来 present 了一个 vc，然后切换成竖屏，考虑到竖屏下横向空间是紧凑的话可以把 popover 调整为 fullscreen。这个方法的本质是咨询 &lt;code&gt;UIPresentationController&lt;/code&gt; 的 &lt;code&gt;delegate&lt;/code&gt; 的 &lt;code&gt;adaptivePresentationStyleForPresentationController:traitCollection:&lt;/code&gt; 来得到一个 style，如果 &lt;code&gt;delegate&lt;/code&gt; 不存在的话则返回 &lt;code&gt;.None&lt;/code&gt;，就是完全不适配不同的 trait collection。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIKit&lt;/code&gt; 向我们的 &lt;code&gt;TransitioningDelegate&lt;/code&gt; 通过 &lt;code&gt;animationControllerForPresentedController(_:presentingController:sourceController:)&lt;/code&gt; 要一个 animator，这里我们是提供 &lt;code&gt;TransitioningAnimator&lt;/code&gt; 来实现自定义的 presentation animation。重申一下在 animator 中我们的 &lt;code&gt;toView&lt;/code&gt;, &lt;code&gt;finalFrame&lt;/code&gt; 之类的一切属性都要从 context 拿，不能简单地假设 frame 就是整个屏幕或者 &lt;code&gt;toView&lt;/code&gt; 就是 presented vc 的 view 之类的。&lt;/li&gt;
&lt;li&gt;我们的 &lt;code&gt;TransitioningDelegate&lt;/code&gt; 提供了所有 &lt;code&gt;UIKit&lt;/code&gt; 需要的信息，它被释放了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIKit&lt;/code&gt; 向 &lt;code&gt;UIPresentationController&lt;/code&gt; 的 &lt;code&gt;shouldRemovePresentersView()&lt;/code&gt; 询问是不是要在 presentation 动画结束后移除掉 presenting 者的 view。我们的 presentation 完成之后是能够透过半透明的视图看到 presenting vc 的，所以应该返回 false（默认就是 false，因此不用重载）。&lt;code&gt;UIKit&lt;/code&gt; 在整个 presentation 的过程中会多次咨询这个方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIPresentationController&lt;/code&gt; 的 &lt;code&gt;presentationTransitionWillBegin()&lt;/code&gt; 被调用。这里我们把自己提供的 &lt;code&gt;dimmingView&lt;/code&gt; 拿出来，把 presented vc 的 view 加到 &lt;code&gt;dimmingView&lt;/code&gt; 上，然后把 &lt;code&gt;dimmingView&lt;/code&gt; 加到 containerView 上，并且用 coordinator 来将 &lt;code&gt;dimmingView&lt;/code&gt; 的 &lt;code&gt;alpha&lt;/code&gt; 从 0 animate 到 1。我们在这里做的事情和 Apple 文档中写的一模一样：把自定义的 view 加入到视图结构中并且 animate 与之相关的东西。&lt;/li&gt;
&lt;li&gt;在前一步中我们调用了 &lt;code&gt;UIPresentationController&lt;/code&gt; 的 &lt;code&gt;presentedView()&lt;/code&gt;。它默认返回 presented vc 的 view，我们可以提供一个不同的 view 来被 present，比如把 presented vc 的 view 包在一个 &lt;code&gt;UINavigationController&lt;/code&gt; 的 view 内再提供出去。注意这个方法会被 &lt;code&gt;UIKit&lt;/code&gt; 调用多次，所以不能在这里进行视图结构的设置，这些应该在第 8 步完成，这里需要迅速返回一个 view。额外扯一下，这是一个微妙的能力，因为国内 iOS 开发者肯定是开发 iPhone app 居多，我们在 present 一个 vc 之前是不是基本上都需要把它包在一个 &lt;code&gt;UINavigationController&lt;/code&gt; 内呢？那么在 iOS 8 之后，我们可以指定 present 的 controller 是一个会把 presented vc 包装在 &lt;code&gt;UINavigationController&lt;/code&gt; 内的 presentation controller，然后只管 present 就行。从实际看它省不了代码（反而还变多了…），不过从另一方面来看它解耦了代码的逻辑：vc 做的事情已经够多了，包装 presented vc 这样的杂事还是交给一个专门的 controller 来做。。。&lt;/li&gt;
&lt;li&gt;然后我们的 animator 的 &lt;code&gt;transitionDuration(_ transitionContext:)&lt;/code&gt; 以及 &lt;code&gt;animateTransition(_ transitionContext:)&lt;/code&gt; 被调用，开始进行自定义 presentation 的动画。这里当我们从 context 中取 &lt;code&gt;toViewController&lt;/code&gt; 的 &lt;code&gt;finalFrame&lt;/code&gt; 时，实际是从 &lt;code&gt;UIPresentationController&lt;/code&gt; 的 &lt;code&gt;frameOfPresentedViewInContainerView()&lt;/code&gt; 中拿的，&lt;code&gt;frameOfPresentedViewInContainerView()&lt;/code&gt; 默认返回 container view 的大小，而在我们的实现中需要 presented vc 的 view 比整个屏幕小一圈，所以我们返回一个自己算的 frame。&lt;code&gt;UIKit&lt;/code&gt; 会调用 &lt;code&gt;frameOfPresentedViewInContainerView()&lt;/code&gt; 多次，所以这里的计算不能太复杂。这里有个微妙的地方是：这里的 frame 是 presented view 在 container view 中的 frame，而我们实际是把 presented view 加在了自己的 &lt;code&gt;dimmingView&lt;/code&gt; 上的，因此这里要注意一致性。我们的 animator 提供的自定义动画会和之前 &lt;code&gt;UIPresentationController&lt;/code&gt; 中 &lt;code&gt;presentationTransitionWillBegin()&lt;/code&gt; 里 coordinator 设置的动画同时进行。&lt;/li&gt;
&lt;li&gt;在动画真正跑起来之前，&lt;code&gt;containerViewWillLayoutSubviews()&lt;/code&gt; 以及 &lt;code&gt;containerViewDidLayoutSubviews()&lt;/code&gt; 会被调用，这里 Apple 的说法是在 &lt;code&gt;containerViewWillLayoutSubviews()&lt;/code&gt; 里调整自定义 view 的位置（我们的 &lt;code&gt;dimmingView&lt;/code&gt;的位置就是在这里设置的），在 &lt;code&gt;containerViewDidLayoutSubviews()&lt;/code&gt; 里对视图结构再作额外的调整。&lt;/li&gt;
&lt;li&gt;经过我们在 animator 里设置好的时间，animator 的动画跑完了，其 completion handler 被调用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;presentationTransitionDidEnd(completed:)&lt;/code&gt; 被调用，这里如果是未完成的话（比如是 interactive 的 presentation，人为取消了）我们需要把 &lt;code&gt;dimmingView&lt;/code&gt; 移除掉，毕竟是自己加上去的。&lt;/li&gt;
&lt;li&gt;至此整个 presentation 就算完成了，&lt;code&gt;presentViewController:animated:completion:&lt;/code&gt; 的 completion 会被调用。&lt;/li&gt;
&lt;li&gt;有趣的是，之前通过 coordinator 设置好的动画的 completion 是最后被调用的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上就是 presentation 过程 &lt;code&gt;UIPresentationController&lt;/code&gt; 在 &lt;code&gt;UIKit&lt;/code&gt; 中是如何工作的详解，知道了这些，我们在使用 &lt;code&gt;UIPresentationController&lt;/code&gt; 进行自定义 presentation 的过程中就能最大限度地与之配合好好工作了。&lt;/p&gt;
&lt;p&gt;有 present 就要有 dismiss，dismiss 的过程与之是类似的，这里不再描述。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UIPresentationController&lt;/code&gt; 还能通过其 &lt;code&gt;delegate&lt;/code&gt; 配合设备的 trait collection 的变化进行 adaptive 的调整。&lt;/p&gt;
&lt;p&gt;看到这里是不是额头上已经冒汗了？搞这么麻烦究竟是为什么啊？&lt;/p&gt;
&lt;h1 id=&quot;Why_3F&quot;&gt;&lt;a href=&quot;#Why_3F&quot; class=&quot;headerlink&quot; title=&quot;Why?&quot;&gt;&lt;/a&gt;Why?&lt;/h1&gt;&lt;p&gt;我对 &lt;code&gt;UIPresentationController&lt;/code&gt; 的理解是逻辑的解耦。通过 &lt;code&gt;UIPresentationController&lt;/code&gt;，被 present 的 vc 可以不必知道自己还需要提供一个半透明的视图能透过去看到 presenting vc，它只需要提供自己的 view 出来；而 presenting vc 也不必亲自对 presented vc 的 view 进行额外处理（比如将其 embed 到 &lt;code&gt;UINavigationController&lt;/code&gt;），它只需要调用 present 就行，present 相关的逻辑都由 &lt;code&gt;UIPresentationController&lt;/code&gt; 来处理；animator 纯粹就是用来 animate presentation 的过程，它不需要知道任何造成耦合的假设，任何信息都从 context 中直接拿；present 完成后，整个 presentation 的环境可以是 adaptive 的（通过 &lt;code&gt;UIAdaptivePresentationControllerDelegate&lt;/code&gt;），并且这个 adaptive 的能力是由 presentation controller 提供的，被 present 的 vc 只要管好自己的 view 就行。&lt;/p&gt;
&lt;p&gt;经过以上的分析，是不是能够理解 Apple 这样调整的理由了呢？&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Written by 饿了么iOS组 － &lt;a href=&quot;https://github.com/axl411&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;axl411&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;现在大多数 app 都已经支持 iOS 7+ 有一段时间了，距离支持 iOS 8+ 的时间也是屈指可数（希望如此…）了。iOS 8 新增的 API 中有一个 &lt;code&gt;UIPresentationController&lt;/code&gt; 一直比较陌生，本文将简略介绍使用 &lt;co
    
    </summary>
    
      <category term="iOS" scheme="http://eleme.io/mobilists/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://eleme.io/mobilists/tags/iOS/"/>
    
      <category term="UIPresentationController" scheme="http://eleme.io/mobilists/tags/UIPresentationController/"/>
    
      <category term="Custom Presentation" scheme="http://eleme.io/mobilists/tags/Custom-Presentation/"/>
    
      <category term="iOS 8" scheme="http://eleme.io/mobilists/tags/iOS-8/"/>
    
  </entry>
  
  <entry>
    <title>突破微信跳转限制－Universal Links那些坑</title>
    <link href="http://eleme.io/mobilists/2016/01/10/%E7%AA%81%E7%A0%B4%E5%BE%AE%E4%BF%A1%E8%B7%B3%E8%BD%AC%E9%99%90%E5%88%B6%EF%BC%8DUniversal-Links%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://eleme.io/mobilists/2016/01/10/突破微信跳转限制－Universal-Links那些坑/</id>
    <published>2016-01-10T13:43:29.000Z</published>
    <updated>2016-01-12T02:36:06.000Z</updated>
    
    <content type="html">&lt;p&gt;微信屏蔽了在其内部webview中大部分URL Scheme跳转（除了一个白名单比如点评），目前突破这个限制有两种方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WXAppExtendObject: 这个用法自查&lt;/li&gt;
&lt;li&gt;Universal Links: 文档在&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/General/Conceptual/AppSearch/UniversalLinks.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt; ，工作原理，如何实现，直接参考官方文档即可&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是我们按照文档支持了Universal Links，却在iOS9.2开始发现不work了，那么下面开始尝试解决问题&lt;/p&gt;
&lt;h2 id=&quot;App_Search_API_Validation_Tool&quot;&gt;&lt;a href=&quot;#App_Search_API_Validation_Tool&quot; class=&quot;headerlink&quot; title=&quot;App Search API Validation Tool&quot;&gt;&lt;/a&gt;App Search API Validation Tool&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;apple官方有出一个工具－&lt;a href=&quot;https://search.developer.apple.com/appsearch-validation-tool/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;App Search API Validation Tool&lt;/a&gt;，这个工具可以测试网站对iOS9 search API的支持，其中包括了对Universal Links的配置检查&lt;/p&gt;
&lt;p&gt;但是这个工具对我们网站检查的结果是 &lt;code&gt;passed&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;iOS_u7AEF_u8868_u73B0_u5206_u6790&quot;&gt;&lt;a href=&quot;#iOS_u7AEF_u8868_u73B0_u5206_u6790&quot; class=&quot;headerlink&quot; title=&quot;iOS端表现分析&quot;&gt;&lt;/a&gt;iOS端表现分析&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;iOS 9.2开始具体变现如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Safari中点击符合条件的Link，没有跳转App，但是长按链接能弹出用饿了么打开链接的选项&lt;/li&gt;
&lt;li&gt;信息app内点击指定Link，works&lt;/li&gt;
&lt;li&gt;微信中打开对应的web，点击符合条件的Link，没有跳转App&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看起来iOS 9.2肯定是有修改相关的机制，但是Apple并没有提供相应的修改说明（反正我们没有搜到），这个也符合apple一贯的作风&lt;/p&gt;
&lt;h2 id=&quot;u7B54_u6848&quot;&gt;&lt;a href=&quot;#u7B54_u6848&quot; class=&quot;headerlink&quot; title=&quot;答案&quot;&gt;&lt;/a&gt;答案&lt;/h2&gt;&lt;p&gt;感谢 &lt;a href=&quot;https://dev.branch.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Branch Metrics&lt;/a&gt;，我在&lt;a href=&quot;https://dev.branch.io/recipes/branch_universal_links/ios/#which-appsbrowsers-support-universal-links&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;找到了答案&lt;/p&gt;
&lt;p&gt;贴上所有的注意点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Universal Links will not work if you paste the link into the browser URL field.&lt;/li&gt;
&lt;li&gt;Universal Links work with a user driven &lt;code&gt;&amp;lt;a href=&amp;quot;...&amp;quot;&amp;gt;&lt;/code&gt; element click across domains. Example: if there is a Universal Link on google.com pointing to bnc.lt, it will open the app.&lt;/li&gt;
&lt;li&gt;Universal Links will not work with a user driven &lt;code&gt;&amp;lt;a href=&amp;quot;...&amp;quot;&amp;gt;&lt;/code&gt; element click on the same domain. Example: if there is a Universal Link on google.com pointing to a different Universal Link on google.com, it will not open the app.&lt;/li&gt;
&lt;li&gt;Universal Links cannot be triggered via Javascript (in window.onload or via a .click() call on an &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; element), unless it is part of a user action.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是从iOS 9.2开始，在相同的domain内Universal Links是不work的，必须要跨域才生效，我们实测值需要跨子域名即可，比如 m.domain.com 跳转 o.domain.com 是可以触发跳转App&lt;/p&gt;
&lt;p&gt;Written by 饿了么iOS组 － Bryan&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;微信屏蔽了在其内部webview中大部分URL Scheme跳转（除了一个白名单比如点评），目前突破这个限制有两种方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WXAppExtendObject: 这个用法自查&lt;/li&gt;
&lt;li&gt;Universal Links: 文档在&lt;a href=&quot;
    
    </summary>
    
      <category term="iOS" scheme="http://eleme.io/mobilists/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://eleme.io/mobilists/tags/iOS/"/>
    
      <category term="Universal Links" scheme="http://eleme.io/mobilists/tags/Universal-Links/"/>
    
      <category term="Wechat" scheme="http://eleme.io/mobilists/tags/Wechat/"/>
    
  </entry>
  
</feed>
